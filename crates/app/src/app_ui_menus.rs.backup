//! UI menu handlers for BitvueApp

use crate::bitvue_app::BitvueApp;
use crate::app_config::BitvueAppConfig;
use crate::app_yuv_diff::BitvueAppYuvDiff;
use crate::settings::{ColorSpace, CpuOptimization};
use crate::yuv_diff::{BitDepth, ChromaSubsampling};
use bitvue_core::StreamId;
use eframe::egui;

/// UI menu methods
pub trait BitvueAppMenus {
    fn handle_file_menu(&mut self, ui: &mut egui::Ui, ctx: &egui::Context);
    fn handle_mode_menu(&mut self, ui: &mut egui::Ui);
    fn handle_yuvdiff_menu(&mut self, ui: &mut egui::Ui);
    fn handle_options_menu(&mut self, ui: &mut egui::Ui, ctx: &egui::Context);
    fn handle_view_menu(&mut self, ui: &mut egui::Ui);
    fn handle_help_menu(&mut self, ui: &mut egui::Ui);
}

impl BitvueAppMenus for BitvueApp {
    fn handle_file_menu(&mut self, ui: &mut egui::Ui, ctx: &egui::Context) {
        let mut path_to_open: Option<std::path::PathBuf> = None;
        let mut close_file = false;
        let mut quit_app = false;

        ui.menu_button("File", |ui| {
            // Open bitstream... (Ctrl+O)
            ui.horizontal(|ui| {
                if ui.button("Open bitstream...").clicked() {
                    if let Some(path) = rfd::FileDialog::new()
                        .add_filter("Video Files", &["ivf", "av1", "mp4", "mkv", "webm", "ts"])
                        .add_filter("All Files", &["*"])
                        .pick_file()
                    {
                        path_to_open = Some(path);
                        ui.close_menu();
                    }
                }
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    ui.label(egui::RichText::new("Ctrl+O").weak());
                });
            });

            // Open bitstream as... (force codec selection)
            ui.menu_button("Open bitstream as...", |ui| {
                ui.label("Force codec parser:");
                ui.separator();
                if ui.button("AV1").clicked() {
                    // TODO: Open with AV1 parser forced
                    self.set_success("Force AV1 parser - not yet implemented".to_string());
                    ui.close_menu();
                }
                if ui.button("HEVC").clicked() {
                    self.set_success("Force HEVC parser - not yet implemented".to_string());
                    ui.close_menu();
                }
                if ui.button("AVC/H.264").clicked() {
                    self.set_success("Force AVC parser - not yet implemented".to_string());
                    ui.close_menu();
                }
                if ui.button("VP9").clicked() {
                    self.set_success("Force VP9 parser - not yet implemented".to_string());
                    ui.close_menu();
                }
                if ui.button("VVC/H.266").clicked() {
                    self.set_success("Force VVC parser - not yet implemented".to_string());
                    ui.close_menu();
                }
                if ui.button("MPEG-2").clicked() {
                    self.set_success("Force MPEG-2 parser - not yet implemented".to_string());
                    ui.close_menu();
                }
            });

            // Open dependent bitstream... (YUV reference)
            if ui.button("Open dependent bitstream...").clicked() {
                // TODO: Open YUV reference file for comparison
                self.set_success("Open dependent bitstream - not yet implemented".to_string());
                ui.close_menu();
            }

            ui.separator();

            // Close bitstream (Ctrl+W)
            ui.horizontal(|ui| {
                if ui.button("Close bitstream").clicked() {
                    close_file = true;
                    ui.close_menu();
                }
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    ui.label(egui::RichText::new("Ctrl+W").weak());
                });
            });

            ui.separator();

            // Extract... submenu
            ui.menu_button("Extract...", |ui| {
                if ui.button("YUV frames").clicked() {
                    self.set_success("Extract YUV - not yet implemented".to_string());
                    ui.close_menu();
                }
                if ui.button("Prediction frames").clicked() {
                    self.set_success("Extract Prediction - not yet implemented".to_string());
                    ui.close_menu();
                }
                if ui.button("Reconstruction frames").clicked() {
                    self.set_success("Extract Reconstruction - not yet implemented".to_string());
                    ui.close_menu();
                }
                if ui.button("Transform coefficients").clicked() {
                    self.set_success("Extract Transform - not yet implemented".to_string());
                    ui.close_menu();
                }
            });

            // Recent files section (VQAnalyzer parity - max 9 files)
            if !self.recent_files.is_empty() {
                ui.separator();
                ui.label("Recent Files:");
                for (i, path) in self.recent_files.iter().enumerate() {
                    let label = format!("{} {}", i + 1,
                        path.file_name()
                            .map(|n| n.to_string_lossy())
                            .unwrap_or_else(|| path.to_string_lossy())
                    );
                    if ui.button(label).on_hover_text(path.display().to_string()).clicked() {
                        path_to_open = Some(path.clone());
                        ui.close_menu();
                    }
                }
                if ui.button("Clear recent files").clicked() {
                    self.recent_files.clear();
                    // Save empty list to disk
                    if let Err(e) = self.save_recent_files() {
                        tracing::warn!("Failed to save recent files: {}", e);
                    }
                    ui.close_menu();
                }
            }

            ui.separator();

            // Quit (Ctrl+Q)
            ui.horizontal(|ui| {
                if ui.button("Quit").clicked() {
                    quit_app = true;
                    ui.close_menu();
                }
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    ui.label(egui::RichText::new("Ctrl+Q").weak());
                });
            });
        });

        // Handle file opening
        if let Some(path) = path_to_open {
            self.open_file(path, ctx);
        }

        // Handle close file
        if close_file {
            self.close_file(ctx);
        }

        // Handle quit
        if quit_app {
            tracing::info!("Quitting application");
            ctx.send_viewport_cmd(egui::ViewportCommand::Close);
        }
    }

    /// Render YUVDiff menu for reference comparison (VQAnalyzer parity - 15 features)
    fn handle_yuvdiff_menu(&mut self, ui: &mut egui::Ui) {
        ui.menu_button("YUVDiff", |ui| {
            if ui.button("Open Dependent...").clicked() {
                // Open reference YUV file for comparison
                if let Some(path) = rfd::FileDialog::new()
                    .set_title("Open Reference YUV File")
                    .add_filter("YUV Files", &["yuv", "y4m"])
                    .add_filter("All Files", &["*"])
                    .pick_file()
                {
                    tracing::info!("Loading reference YUV: {:?}", path);
                    self.yuv_diff_settings.reference_file = Some(path);
                    ui.close_menu();
                }
            }

            ui.separator();

            // Frame offset setting
            ui.label("Frame Offset:");
            ui.add(egui::DragValue::new(&mut self.yuv_diff_settings.frame_offset)
                .speed(1)
                .range(-1000..=1000));

            ui.separator();

            // Subsampling submenu
            ui.menu_button("Chroma Subsampling", |ui| {
                if ui.radio_value(&mut self.yuv_diff_settings.subsampling, ChromaSubsampling::Yuv420, "4:2:0").clicked() {
                    ui.close_menu();
                }
                if ui.radio_value(&mut self.yuv_diff_settings.subsampling, ChromaSubsampling::Yuv422, "4:2:2").clicked() {
                    ui.close_menu();
                }
                if ui.radio_value(&mut self.yuv_diff_settings.subsampling, ChromaSubsampling::Yuv444, "4:4:4").clicked() {
                    ui.close_menu();
                }
            });

            // Bit depth submenu
            ui.menu_button("Bit Depth", |ui| {
                if ui.radio_value(&mut self.yuv_diff_settings.bit_depth, BitDepth::Bit8, "8-bit").clicked() {
                    ui.close_menu();
                }
                if ui.radio_value(&mut self.yuv_diff_settings.bit_depth, BitDepth::Bit10, "10-bit").clicked() {
                    ui.close_menu();
                }
                if ui.radio_value(&mut self.yuv_diff_settings.bit_depth, BitDepth::Bit12, "12-bit").clicked() {
                    ui.close_menu();
                }
            });

            ui.separator();

            // Visualization toggles
            ui.checkbox(&mut self.yuv_diff_settings.show_psnr_map, "Show PSNR Map");
            ui.checkbox(&mut self.yuv_diff_settings.show_ssim_map, "Show SSIM Map");
            ui.checkbox(&mut self.yuv_diff_settings.show_delta, "Show Delta Image");

            ui.separator();

            // Export options
            ui.checkbox(&mut self.yuv_diff_settings.export_all_frames, "Export All Frames")
                .on_hover_text("Export metrics for all frames (requires frames to be decoded)");

            if ui.button("Export Metrics CSV...").clicked() {
                // Export PSNR/SSIM metrics to CSV
                if let Some(ref _ref_file) = self.yuv_diff_settings.reference_file {
                    if let Some(path) = rfd::FileDialog::new()
                        .set_file_name("metrics.csv")
                        .add_filter("CSV Files", &["csv"])
                        .save_file()
                    {
                        tracing::info!("Exporting metrics to {:?}", path);
                        match self.export_diff_metrics_csv(&path, self.yuv_diff_settings.export_all_frames) {
                            Ok(()) => {
                                self.set_success(format!("Metrics exported to {}", path.display()));
                            }
                            Err(e) => {
                                self.set_error(format!("Export failed: {}", e));
                            }
                        }
                        ui.close_menu();
                    }
                } else {
                    tracing::warn!("No reference file loaded for metrics export");
                    self.set_error("Load a reference YUV file first".to_string());
                }
            }

            if ui.button("Close Reference").clicked() {
                self.yuv_diff_settings.reference_file = None;
                self.yuv_diff_settings.reference_frame = None;
                self.yuv_diff_settings.reference_dimensions = None;
                self.yuv_diff_settings.psnr_value = None;
                self.yuv_diff_settings.ssim_value = None;
                self.yuv_diff_settings.psnr_yuv_value = None;
                self.yuv_diff_settings.ssim_yuv_value = None;
                self.yuv_diff_settings.show_psnr_map = false;
                self.yuv_diff_settings.show_ssim_map = false;
                self.yuv_diff_settings.show_delta = false;
                tracing::info!("Reference YUV file closed");
                ui.close_menu();
            }
        });
    }

    // Export menu removed - functionality moved to File ‚Üí Extract submenu

    /// Render Options menu (VQAnalyzer parity - Phase 4)
    fn handle_options_menu(&mut self, ui: &mut egui::Ui, ctx: &egui::Context) {
                // Export frame sizes to CSV
                let stream_a = self.core.get_stream(StreamId::A);
                let state = stream_a.read();

                if let Some(ref units_model) = state.units {
                    if let Some(path) = rfd::FileDialog::new()
                        .set_file_name("frame_sizes.csv")
                        .add_filter("CSV Files", &["csv"])
                        .save_file()
                    {
                        match crate::export::export_frames_csv(&units_model.units, &path) {
                            Ok(_) => self.set_success(format!(
                                "Exported frame sizes to {}",
                                path.display()
                            )),
                            Err(e) => self.set_error(format!("Export failed: {}", e)),
                        }
                    }
                } else {
                    tracing::warn!("No units to export");
                }
                ui.close_menu();
            }

            if ui.button("üå≥ Unit Tree (JSON)").clicked() {
                // Export unit tree to JSON
                let stream_a = self.core.get_stream(StreamId::A);
                let state = stream_a.read();

                if let Some(ref units_model) = state.units {
                    if let Some(path) = rfd::FileDialog::new()
                        .set_file_name("units.json")
                        .add_filter("JSON Files", &["json"])
                        .save_file()
                    {
                        match crate::export::export_units_json(&units_model.units, &path) {
                            Ok(_) => self.set_success(format!(
                                "Exported unit tree to {}",
                                path.display()
                            )),
                            Err(e) => self.set_error(format!("Export failed: {}", e)),
                        }
                    }
                } else {
                    tracing::warn!("No units to export");
                }
                ui.close_menu();
            }

            if ui.button("üîç Syntax Tree (JSON)").clicked() {
                // Export syntax tree to JSON
                let stream_a = self.core.get_stream(StreamId::A);
                let state = stream_a.read();

                if let Some(ref syntax) = state.syntax {
                    if let Some(path) = rfd::FileDialog::new()
                        .set_file_name("syntax.json")
                        .add_filter("JSON Files", &["json"])
                        .save_file()
                    {
                        match crate::export::export_syntax_json(syntax, &path) {
                            Ok(_) => self.set_success(format!(
                                "Exported syntax to {}",
                                path.display()
                            )),
                            Err(e) => self.set_error(format!("Export failed: {}", e)),
                        }
                    }
                } else {
                    tracing::warn!("No syntax to export (select a unit first)");
                }
                ui.close_menu();
            }

            ui.separator();

            if ui.button("Evidence Bundle...").clicked() {
                // Export evidence bundle (per export_entrypoints.json)
                use bitvue_core::export::export_evidence_bundle;
                use bitvue_core::export::EvidenceBundleExportRequest;
                use bitvue_core::parity_harness::{
                    EntityRef, OrderType, SelectionSnapshot,
                };

                if let Some(dir) = rfd::FileDialog::new()
                    .set_title("Select Evidence Bundle Output Directory")
                    .pick_folder()
                {
                    let stream_a = self.core.get_stream(StreamId::A);
                    let state = stream_a.read();
                    let selection = self.core.get_selection();
                    let sel_guard = selection.read();

                    // Build stream fingerprint from file path
                    let stream_fingerprint = state
                        .file_path
                        .as_ref()
                        .map(|p| format!("{:?}", p))
                        .unwrap_or_default();

                    let request = EvidenceBundleExportRequest {
                        output_dir: dir.clone(),
                        include_screenshots: true,
                        include_render_snapshots: true,
                        include_interaction_trace: false,
                        include_logs: false,
                        stream_fingerprint,
                        selection_state: SelectionSnapshot {
                            selected_entity: sel_guard.unit.as_ref().map(|u| EntityRef {
                                kind: "unit".to_string(),
                                id: format!("{}:{}", u.unit_type, u.offset),
                                frame_index: None,
                                byte_offset: Some(u.offset),
                            }),
                            selected_byte_range: sel_guard
                                .bit_range
                                .as_ref()
                                .map(|r| (r.start_bit / 8, r.end_bit / 8)),
                            order_type: OrderType::Display,
                        },
                        workspace: "player".to_string(),
                        mode: "normal".to_string(),
                        order_type: OrderType::Display,
                    };

                    let result = export_evidence_bundle(&request, &[]);

                    if result.success {
                        tracing::info!(
                            "Evidence bundle exported to {:?}",
                            result.bundle_path
                        );
                    } else {
                        tracing::error!(
                            "Evidence bundle export failed: {:?}",
                            result.error
                        );
                    }
                }
                ui.close_menu();
            }
        });
    }

    /// Render Options menu (VQAnalyzer parity - Phase 4)
    fn handle_options_menu(&mut self, ui: &mut egui::Ui, ctx: &egui::Context) {
        ui.menu_button("Options", |ui| {
            // Color Space submenu
            ui.menu_button("Color Space", |ui| {
                if ui.radio_value(&mut self.app_settings.color_space, ColorSpace::Bt601, ColorSpace::Bt601.label()).clicked() {
                    tracing::info!("Color space changed to BT.601");
                    ui.close_menu();
                }
                if ui.radio_value(&mut self.app_settings.color_space, ColorSpace::Bt709, ColorSpace::Bt709.label()).clicked() {
                    tracing::info!("Color space changed to BT.709");
                    ui.close_menu();
                }
                if ui.radio_value(&mut self.app_settings.color_space, ColorSpace::Bt2020, ColorSpace::Bt2020.label()).clicked() {
                    tracing::info!("Color space changed to BT.2020");
                    ui.close_menu();
                }
            });

            // CPU Optimization submenu
            ui.menu_button("CPU Optimization", |ui| {
                if ui.radio_value(&mut self.app_settings.cpu_optimization, CpuOptimization::Auto, CpuOptimization::Auto.label()).clicked() {
                    tracing::info!("CPU optimization: Auto (SIMD enabled)");
                    ui.close_menu();
                }
                if ui.radio_value(&mut self.app_settings.cpu_optimization, CpuOptimization::Disabled, CpuOptimization::Disabled.label()).clicked() {
                    tracing::info!("CPU optimization: Disabled (scalar only)");
                    ui.close_menu();
                }
            });

            ui.separator();

            // Theme submenu
            ui.menu_button("Theme", |ui| {
                let mut changed = false;
                if ui.radio_value(&mut self.app_settings.theme, egui::Theme::Dark, "Dark").clicked() {
                    changed = true;
                    ui.close_menu();
                }
                if ui.radio_value(&mut self.app_settings.theme, egui::Theme::Light, "Light").clicked() {
                    changed = true;
                    ui.close_menu();
                }
                if changed {
                    ctx.set_theme(self.app_settings.theme);
                    tracing::info!("Theme changed to {:?}", self.app_settings.theme);
                }
            });

            ui.separator();

            // Layout management
            if ui.button("Reset Layout").clicked() {
                tracing::info!("Resetting layout to default (from Options menu)");
                self.dock_state = self.default_dock_state.clone();
                ui.close_menu();
            }

            if ui.button("Save Layout...").clicked() {
                match self.save_layout() {
                    Ok(()) => {
                        self.set_success("Layout saved to ~/.bitvue/layout.json".to_string());
                    }
                    Err(e) => {
                        self.set_error(format!("Failed to save layout: {}", e));
                    }
                }
                ui.close_menu();
            }

            if ui.button("Load Layout...").clicked() {
                match self.load_layout() {
                    Ok(()) => {
                        self.set_success("Layout loaded from ~/.bitvue/layout.json".to_string());
                    }
                    Err(e) => {
                        self.set_error(format!("Failed to load layout: {}", e));
                    }
                }
                ui.close_menu();
            }

            ui.separator();

            // Auto-save layout on exit option
            ui.checkbox(&mut self.app_settings.auto_save_layout, "Auto-save layout on exit")
                .on_hover_text("Automatically save panel layout when closing the application");
        });
    }

    /// Render Mode menu (VQAnalyzer parity - F1-F12 visualization modes)
    fn handle_mode_menu(&mut self, ui: &mut egui::Ui) {
        ui.menu_button("Mode", |ui| {
            if ui.button("Overview (F1)").on_hover_text("High-level statistics").clicked() {
                // TODO: Switch to overview mode
                tracing::info!("Mode: Overview");
                ui.close_menu();
            }
            if ui.button("Coding Flow (F2)").on_hover_text("CTB grid with block types").clicked() {
                tracing::info!("Mode: Coding Flow");
                ui.close_menu();
            }
            if ui.button("Prediction (F3)").on_hover_text("Intra/inter prediction modes").clicked() {
                tracing::info!("Mode: Prediction");
                ui.close_menu();
            }
            if ui.button("Transform (F4)").on_hover_text("Transform unit tree").clicked() {
                tracing::info!("Mode: Transform");
                ui.close_menu();
            }
            if ui.button("QP Map (F5)").on_hover_text("Quantization parameter heatmap").clicked() {
                tracing::info!("Mode: QP Map");
                ui.close_menu();
            }
        });
    }

    /// Render View menu (VQAnalyzer parity)
    fn handle_view_menu(&mut self, ui: &mut egui::Ui) {
        ui.menu_button("View", |ui| {
            ui.label("Layout:");
            ui.separator();

            if ui.button("Reset Layout").clicked() {
                tracing::info!("Resetting layout to default");
                self.dock_state = self.default_dock_state.clone();
                ui.close_menu();
            }

            ui.separator();
            ui.label("Panels:");

            // TODO: Panel visibility toggles
            ui.checkbox(&mut true, "Stream Tree");
            ui.checkbox(&mut true, "Player");
            ui.checkbox(&mut true, "Diagnostics");
        });
    }

    /// Render Help menu (VQAnalyzer parity)
    fn handle_help_menu(&mut self, ui: &mut egui::Ui) {
        ui.menu_button("Help", |ui| {
            if ui.button("Documentation").clicked() {
                self.set_success("Opening documentation...".to_string());
                ui.close_menu();
            }

            if ui.button("Keyboard Shortcuts").clicked() {
                self.set_success("Ctrl+O: Open | Ctrl+W: Close | Ctrl+Q: Quit | F1-F5: Modes | ‚Üê‚Üí: Navigate frames".to_string());
                ui.close_menu();
            }

            ui.separator();

            if ui.button("About bitvue").clicked() {
                self.set_success(format!("bitvue v{} - Open Source Bitstream Analyzer", env!("CARGO_PKG_VERSION")));
                ui.close_menu();
            }
        });
    }

}
