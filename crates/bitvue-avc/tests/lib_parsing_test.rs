#![allow(dead_code)]
// Tests for lib.rs parsing functions
use bitvue_avc::{parse_avc, parse_avc_quick, AvcQuickInfo};

// ============================================================================
// Tests for parse_avc_quick function
// ============================================================================

#[test]
fn test_parse_avc_quick_with_valid_sps() {
    let data = [
        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1E, 0x8B, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
        0x00,
    ];

    let result = parse_avc_quick(&data);
    assert!(result.is_ok());
}

#[test]
fn test_parse_avc_quick_multiple_sps() {
    let data = [
        // First SPS
        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1E, 0x8B, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
        0x00, // Second SPS
        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1E, 0x8D, 0x04, 0x08, 0x08, 0x00, 0x00, 0x00,
        0x00,
    ];

    let result = parse_avc_quick(&data);
    assert!(result.is_ok());
}

#[test]
fn test_parse_avc_quick_with_pps() {
    let data = [
        // SPS
        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1E, 0x8B, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
        0x00, // PPS
        0x00, 0x00, 0x00, 0x01, 0x68, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    let result = parse_avc_quick(&data);
    assert!(result.is_ok());
}

#[test]
fn test_parse_avc_quick_idr_slice() {
    let data = [
        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1E, 0x8B, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x68, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x65, 0x80, 0x40, 0x04, 0x00, 0x00, 0x00,
    ];

    let result = parse_avc_quick(&data);
    assert!(result.is_ok());
}

#[test]
fn test_parse_avc_quick_p_slice() {
    let data = [
        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1E, 0x8B, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x68, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x41, 0x80, 0x00, 0x04, 0x00, 0x00,
    ];

    let result = parse_avc_quick(&data);
    assert!(result.is_ok());
}

#[test]
fn test_parse_avc_quick_b_slice() {
    let data = [
        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1E, 0x8B, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x68, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x21, 0x80, 0x80, 0x04, 0x00, 0x00,
    ];

    let result = parse_avc_quick(&data);
    assert!(result.is_ok());
}

#[test]
fn test_parse_avc_quick_various_sps_ids() {
    for sps_id in 0u8..5u8 {
        let data = [
            0x00,
            0x00,
            0x00,
            0x01,
            0x67,
            0x42,
            0x00,
            0x1E,
            (sps_id << 1) | 0x80, // sps_id
            0x04,
            0x04,
            0x04,
            0x00,
            0x00,
            0x00,
            0x00,
        ];

        let result = parse_avc_quick(&data);
        assert!(result.is_ok());
    }
}

#[test]
fn test_parse_avc_quick_various_dimensions() {
    for (width_mbs, height_mbs) in [(0u8, 0u8), (1, 1), (3, 3), (10, 10)] {
        let data = [
            0x00,
            0x00,
            0x00,
            0x01,
            0x67,
            0x42,
            0x00,
            0x1E,
            0x8B,
            0x04,
            (width_mbs << 1) | 0x80,
            (height_mbs << 1) | 0x80,
            0x00,
            0x00,
            0x00,
            0x00,
        ];

        let result = parse_avc_quick(&data);
        assert!(result.is_ok());
    }
}

#[test]
fn test_parse_avc_quick_profile_variants() {
    for profile in [66u8, 77u8, 100u8, 110u8, 122u8] {
        let data = [
            0x00, 0x00, 0x00, 0x01, 0x67, profile, 0x00, 0x1E, 0x8B, 0x04, 0x04, 0x04, 0x00, 0x00,
            0x00, 0x00,
        ];

        let result = parse_avc_quick(&data);
        assert!(result.is_ok());
    }
}

#[test]
fn test_parse_avc_quick_level_variants() {
    for level in [10u8, 20u8, 30u8, 40u8, 50u8, 51u8] {
        let data = [
            0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, level, 0x8B, 0x04, 0x04, 0x04, 0x00, 0x00,
            0x00, 0x00,
        ];

        let result = parse_avc_quick(&data);
        assert!(result.is_ok());
    }
}

#[test]
fn test_parse_avc_quick_three_byte_start_code() {
    let data = [
        0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1E, 0x8B, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00,
    ];

    let result = parse_avc_quick(&data);
    assert!(result.is_ok());
}

#[test]
fn test_parse_avc_quick_four_byte_start_code() {
    let data = [
        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1E, 0x8B, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
        0x00,
    ];

    let result = parse_avc_quick(&data);
    assert!(result.is_ok());
}

#[test]
fn test_parse_avc_quick_mixed_nal_types() {
    let data = [
        0x00, 0x00, 0x00, 0x01, 0x0C, 0xFF, 0xFF, // Filler
        0x00, 0x00, 0x00, 0x01, 0x06, 0x01, 0xFF, 0x80, // SEI
        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1E, 0x8B, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
        0x00, // SPS
    ];

    let result = parse_avc_quick(&data);
    assert!(result.is_ok());
}

#[test]
fn test_parse_avc_multiple_nal_before_sps() {
    let data = [
        0x00, 0x00, 0x00, 0x01, 0x0C, 0xFF, // Filler
        0x00, 0x00, 0x00, 0x01, 0x06, 0x01, 0xFF, 0x80, // SEI
        0x00, 0x00, 0x00, 0x01, 0x68, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, // PPS
        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1E, 0x8B, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
        0x00, // SPS
    ];

    let result = parse_avc(&data);
    assert!(result.is_ok());
}
